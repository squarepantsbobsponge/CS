大模型障碍注入，检查系统

大模型和智能体交互

大模型应用工具链（终端...）

内核的enfp程序

车载系统的注入障碍



[TOC]

Rope

旋转位置编码：

![image-20240922214601448](C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20240922214601448.png)

![image-20240922214638078](C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20240922214638078.png)

![image-20240922214713455](C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20240922214713455.png)

扩展到多维：

![image-20240922221254378](C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20240922221254378.png)

![image-20240922221411720](C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20240922221411720.png)

rotoary embeddings：

利用词向量间的角度差异代表词向量的位置差距

## Efficient Reproduction of Fault-Induced Failures in Distributed Systems with Feedback-Driven Fault Injection  

#### introduction:

* 要求：既要复现bug和其工作流，又要能够快速修复和快速复现

* 问题：有需要外部刺激的故障，有随机不知道原因的故障，现在的故障注入只能确定性注入或者迭代运行（不能注入不知道根本原因的故障和再现故障的成本大）

* 关键：找到故障的根本原因（但是不能直接照搬错误日志）

* 解决：注入一个故障，根据它的表现和相关信息来估计相关故障能复现目标故障的可能性
  * 定义哪些运行时信息可以捕获这种相关性
  * 如何使用它根据再现故障的可能性对未探索的故障进行排名
  * 以及如何在每次故障注入后更新排名

* 设计思想：
  * 用静态分析来修剪与给定障碍无关的故障点
  * 用动态反馈分析，先假定所有日志信息一样重要，基于和信息的因果联系计算故障点的优先级，不断选择最高优先级的故障注入，并根据执行信息重新定义优先级

#### Background and Motivation  

* 故障诱发故障：没被解决/解决程序小的故障
* 背景：
  * 开源分布系统
  * 没被过滤的失败的日志
  * 工作负载：使用现有的测试；自动生成输入；按照故障表现定制
  * 故障复现的判断标准（用户定义）：它封装了关键故障症状，例如特定的日志消息、可能在日志文件中也可能不在日志文件中的堆栈跟踪，或外部状态，例如损坏的数据文件。
* 例子：
  * WAL：在使用WAL的系统中，所有的修改在生效（或提交）之前都要先写入log文件中。这种机制确保了即使在系统崩溃或发生故障时，也能通过重新应用这些日志记录来恢复数据到一致的状态。
  * WAL rolling：即写前日志滚动，指的是在数据库或分布式存储系统中，当当前的WAL（Write-Ahead Logging）文件达到一定大小或满足其他特定条件时，系统会切换到一个新的WAL文件继续记录日志的过程。
  * 问题：在WAL追加时卡住了，但是WAL消费线程存在。
  * 问题分析：所有未追加成功的WAL请求会放在一个队列里面重新尝试，当到达WAL rolling和系统需要关闭的节点时会触发safepoint，线程阻塞，同步所有未追加成功的WAL，保证数据一致性和系统可靠性。但是可能队列需要多次消费才能清空，在safepoint这个点上消费者既不会发出条件信号，也不会在后续的调用中执行同步操作，因此无法恢复。即使RegionServer尝试关闭，也会因为卡在waitForSafePoint上而无法正常关闭。

#### Overview of Anduril  

* Anduril：一种故障注入工具，具有重现生产中发生的特定故障引起的故障的独特能力

  * 静态推理： 对系统代码进行潜在因果推理

  * 优先级的动态调整

  * 组件：

    <img src="C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20241008124143090.png" alt="image-20241008124143090" style="zoom:50%;" />

    * Instrumenter(插装器)：在程序代码中插入额外的代码或指令，以便收集程序在执行时的行为信息
      * 输入：系统字节码和错误日志文件
      * 进行静态分析，生成因果图找到可能故障点
      * 插入代码片段到系统（注入错误）
    * Explorer:
      * 目标：快速搜索根本原因故障的位置和注入时间
      * 输入：因果图，工作负载，故障日志，复现标准
      * 生成一个日志文件（在工作负载且没有注入任何故障的情况下）
      * 计算优先级基于因果图，错误日志和上面的日志文件
      * 选择优先级最高的故障注入，成功就生成脚本不成功就重新计算优先级重新计算

* Feedback定义：

  * 故障特征：该故障对程序执行的影响，采用日志消息作为特征

#### Instrumenter  

* 计算因果图：

  <img src="C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20241008185923022.png" alt="image-20241008185923022" style="zoom:50%;" />

  * 将日志消息和故障点联系起来（故障点是程序中抛出异常的地方）

  * 为了观察到全面的数据流，用跳跃策略

    * 给定if (x==y)，直接在写x或y的函数中搜索程序点，并将它们视为可能的因果关系。

  * 因果图：节点就是图中的点，因果分析和异常分析就是边
    <img src="C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20241008131745515.png" alt="image-20241008131745515" style="zoom:67%;" />

    * 加入异常流分析
    * 源节点为故障根本原因，汇节点（无出边）为日志消息（相当于故障表现）

  * 异常分析：

    * 处理程序节点：到达异常处理程序的入口点
    * 内部错误节点：是调用系统内部函数时的抛出异常，但是不是源头，是被传播的
    * new-exception ：被系统内部函数调用抛出的异常，而这个内部函数为异常创建者
    * 外部异常节点：表示由标准库或第三方库中的方法抛出的异常

    * 在寻找因果先验节点的递归分析遇到new和外部时停止
    * Instrumenter通过在因果图中标识的故障点插入相应的代码，使得Explorer能够在这些点上拦截并处理潜在的故障。

* 提供注入代码和跟踪代码（跟踪故障)

  （如。在故障点`out.write`被执行之前，插入的`traceSite()`（第5行）调用会记录该点的相关信息。之后，插入的`throwExceptionIfEnabled`（第7行）会检查Explorer是否希望在此处尝试任何故障候选，并相应地抛出一个异常。）

* 先找到故障点，然后确立关系图的起点终点，然后推理因果前点并且连线

#### Explorer  

* 确定相关观测值，只和目标障碍有关的消息

  * 正常日志和故障日志找不同，得到故障日志专有信息；清理时间戳，如果故障日志中包含正常日志中没有的线程，我们将这些线程的所有日志消息都视为相关的可观察对象。
  * 使用：
    * 生成计算图
    * 更新观测对象和观测值：故障注入未成功时，该轮次自然会生成一个正常的日志文件。然后，Anduril会对新的日志文件重新执行日志比较算法，以获得更新后的相关可观察对象列表
    * 原则：第一步计算出的相关可观察对象将是第二步中相关可观察对象的超集，只关心故障日志里面的消息以及避免重复计算计算图

* 反馈算法：

  * 更新可观察对象反馈

    * 原理：首先考虑未成功注入的可观察对象：注入未能再现目标故障，查看预期出现但未出现的可观察对象。这些缺失的可观察对象可能与故障相关，则可以找到可能导致它们的故障。

    * 实现：每个相关可观察对象𝑜𝑘分配一个优先级𝐼𝑘。（较小的值来表示较高的优先级）
      * 最初，所有𝐼𝑘都为零。
      * 当注入未成功时，比较运行日志与故障日志，以确定因果图中哪些可观察对象出现在当前日志中，哪些缺失。
      * 然后，它会在后续轮次中优先处理这些缺失的消息，因此会为每个出现的消息将其𝐼𝑘增加1。
        <img src="C:\Users\丁晓琪\AppData\Roaming\Typora\typora-user-images\image-20241008193847211.png" alt="image-20241008193847211" style="zoom:67%;" />

  * 更新故障站点优先级(因果图中的源节点)：

    * 方法：
      * 将故障优先级设置为能够引起的可观察对象的（最大）优先级。效率低
      * 故障不一定会产生它在因果图中所有路径上的可观察对象。路径上的可观察对象越远，它产生的确定性就越低。可以考虑观察对象在因果图中的空间位置

  * 更新故障实例优先级：

    * 𝑓𝑖：仅指静态故障候选，即异常类型及其在代码中的位置。
    * $f_{i,j}$：故障实例：表示故障点𝑓𝑖的第𝑗次出现。需要智能地选择要探索的实例。

    * 𝑇𝑖,𝑗,𝑘：故障实例𝑓𝑖,𝑗与想要触发的可观察对象𝑜𝑘之间的时间距离来确定故障实例的优先级。
    * 逻辑时间距离确定𝑇𝑖,𝑗,𝑘：计算𝑓𝑖,𝑗和𝑜𝑘之间的日志消息数量。日志消息的存在表明系统中可能发生了状态变化；通过消息数量表示的距离指示了达到可观察对象所需的状态变化，这比故障实例的相对顺序更稳健。

    * 计算𝑇𝑖,𝑗,𝑘：获得第一个正常日志时收集故障实例的分布情况。？？

  * 总和所有优先级：

    * 首先专注于选择高优先级的故障点。不考虑时间信息。
      * 对于故障点𝑓𝑖，考虑它在因果图中涉及的所有可观测量。（𝑝𝑖,𝑘表示在考虑其因果可观测量𝑜𝑘时，故障点𝑓𝑖的部分优先级）
      * 完整优先级𝐹𝑖将是𝑝𝑖,𝑘的某种聚合。min𝑘 (𝑝𝑖,𝑘)1，或者是$\sum$(𝑝𝑖,𝑘)
      * 𝐼𝑘（𝑜𝑘的优先级）和𝐿𝑖,𝑘（从𝑓𝑖到𝑜𝑘的距离）𝐹𝑖 = min𝑘 (𝐿𝑖,𝑘 + 𝐼𝑘)。
    * 选择高优先级的故障点实例:
      * (利用𝑇𝑖,𝑗,𝑘来对同一故障注入点的所有𝑁个实例进行排序)𝐹𝑖,𝑗（𝑓𝑖,𝑗的优先级）表示为$min_{0≤𝑗 ≤𝑁 ,𝑜𝑘 }𝑇𝑖,𝑗,𝑘$。
      * 注意，𝑜𝑘是在选择𝐹𝑖的第一阶段确定的。同时，在反馈过程中，𝑜𝑘是可以改变的。到那时，将使用不同的𝑘来计算𝐹𝑖,𝑗。

    * 在每次试验中，Anduril选择故障实例𝑓𝑖,𝑗，使得min𝑖 (𝐹𝑖)和min𝑗 (𝐹𝑖,𝑗)均得到满足。

  * 灵活优先级窗口：考虑前𝑘个最高优先级的故障候选者。

    * 如果窗口中的任何候选者发生，Anduril将注入该故障候选者，即使它不具有最高优先级，并从窗口中移除该候选者。
    * 如果一轮中没有注入任何故障，Anduril会将下一轮的窗口大小𝑘加倍，以考虑更多的候选者。

    

## If At First You Don’t Succeed, Try, Try, Again...?(Insights and LLM-informed Tooling for Detecting Retry Bugs in Software Systems )

#### introduction

* 存在问题：
  * 错误是否值得重试和什么时候重试
  * 如何执行重试：如何跟踪作业状态，如何在任务未完成后清理程序状态，以及如何再次(一次又一次)启动作业
* WASABI：组合了静态程序分析、大型语言模型、故障注入和单元测试的工具包，用于处理与循环和非循环相关的重试中的所有三种类型的重试相关错误(上面提到的IF、WHEN和HOW问题)。
  * 包含动态工作流和静态工作流
  * 不需要人工设置特殊的单元测试，会自动更改单元测试暴露重试bug